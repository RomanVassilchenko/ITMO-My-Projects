; 1. Массив имеет следующие характеристики:
; - адрес начала массива в памяти БЭВМ - 0x6c8;
; - число измерений исходного массива - 1;
; - количество элементов исходного массива - 23;
; - каждый элемент является знаковым числом с разрядностью 10 бит;
; - нумерация элементов начинается с 4;
; - элементы хранятся в массиве по границам слов, нет необходимости в плотной упаковке;
; 2. Для каждого элемента массива необходимо вычислить функцию:
; - формула функции F(Mi) = 6 * Mi + 309;
; - функцию вычислять только для элементов массива с кратными 3-м i-индексами;
; - если результат вычисления функции выходит за пределы области допустимых значений элемента массива из п.1, то он принимается равным 275
; 3. Из всех полученных значений функции необходимо вычислить минимальное значение, и записать в 32-разрядный результат.
; Примечание: все числа представлены в десятичной системе счисления, если явно не указано иное.

ORG 0x6c8
WORD ?
; ...

ORG 0x0
FirstEl: WORD 0x6c8 ; Первый элемент массива
CurrEl: WORD 0x6c8  ; Нынешний элемент массива
N: WORD 0x17        ; Количество оставшихся элементов
I: WORD 0x4         ; Индекс элемента

MinEl1: WORD 0x0
MinEl2: WORD 0x7FFF  ; Минимальный элемент

STOP: LD MinEl2
CMP #0x0
BNE NegativeMin
BGE PositiveMin

NegativeMin:
CLA
DEC
ST MinEl1
HLT           ; Останова

PositiveMin:
CLA
ST MinEl1
HLT           ; Останова
START:

LD FirstEl  ; Загрузка ссылки на первый элемент в CurrEl
ST CurrEl

JOB: LD N       ; Загружаем количество
CMP #0x0        ; элементов и проверяем,
BEQ STOP  ; что осталось не 0 элементов

LD I    ; Загружаем нынешний I
PUSH    ; Закидываем его в стек
CALL CheckI         ; Запускаем подпрограмму
POP                 ; на проверку кратности I
CMP #0x0            ; на 3 и в случае кратности (Если равно 0), то
BEQ RUNFUNC    ; вызываем RUNFUNC
JUMP PostJob

RUNFUNC: LD (CurrEl)+ ; Получаем значение по указателю на нынешний элемент
PUSH        ; Отправляем значение
CALL FUNC   ; в функцию и получаем
POP         ; F(Mi) = 6 * Mi + 309 или 275

CMP MinEl2       ; Если элемент меньше,
BGE PostJob   ; чем наименьший, то закидываем
ST MinEl2        ; его в переменную MinEl2

PostJob: ; Увеличиваем I
LD I 
INC
ST I
LD N ; Уменьшаем J
DEC
ST N

JUMP JOB ; Переход на следующий элемент

FUNC:
MaxConst: WORD 0x0077
MinConst: WORD 0xFF22
LD &1 ; Получаем значение (Mi)
TMP: WORD ?
ST TMP
CMP MaxConst ; Если больше, чем 119, то SkipFunc
BPL SkipFunc
CMP MinConst ; Если меньше, чем -222, то SkipFunc
BNE SkipFunc

FuncConst: WORD 0x135
ASL         ;
ASL         ;
ADD TMP     ; F(Mi) = 6 * Mi + 309
ADD TMP     ;
ADD FuncConst

ST &1 ; Отправляем результат в стек и возвращаемся
RET
ElseConst: WORD 0x113
SkipFunc: LD ElseConst ; Если вне области значений, то 275
ST &1
RET


CheckI: LD &1 ; Сравниваем I с 3
CMP #0x3
BEQ EqualI ; Если равно, то кратно и возвращаем 0
BPL PositiveI ; Если больше, то уменьшаем на 3 и вызываем заново
BNE NegativeI ; Если меньше, то не кратно и возвращаем отрицательное число

PositiveI:
SUB #0x3
ST &1
CALL CheckI
RET

NegativeI:
CLA
DEC
ST &1
RET

EqualI:
CLA
ST &1
RET