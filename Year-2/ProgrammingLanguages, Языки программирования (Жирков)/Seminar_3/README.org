#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+INCLUDE: "../common/org-header.org"

#+TITLE: Семинар 3: Цикл компиляции, препроцессор, утилита make

  Как мы узнали из лекций, чтобы успешно создать и развивать хоть сколько-нибудь
  большую систему необходимо следовать двум принципам:

  - делить систему на части-модули;
  - абстрагировать эти модули, то есть максимально скрывать их внутреннее устройство.

  Исходный код программы после трансляции в машинные инструкции и запуска
  приложения "встраивается" в вычислительную систему. Когда программа написана в
  одном большом файле, при её запуске в вычислительную систему добавляется большой
  модуля, который сложно изучать и отлаживать. Если же разделить исходный код на
  файлы, то запуск программы можно мысленно воспринимать как внесение в систему
  нескольких модулей поменьше. Это существенно облегчает труд разработчиков
  системы.

  В этом семинаре мы глубже познакомимся с тем, как программа из исходного кода
  становится исполняемым файлом.

* Цикл компиляции


  Исходный код преобразуется в набор машинных инструкций, которые можно выполнить на процессоре, в несколько больших этапов (каждый из них может состоять из многих меньших этапов):

  - Препроцессинг ::  преобразование текстового файла на ассемблере с директивами макропроцессора в текстовый файл на ассемблере уже без этих директив. Этим занимается *препроцессор* — отдельная программа или часть компилятора.
  - Трансляция :: преобразование текстового файла на ассемблере в объектный файл. Этим занимается сам **компилятор** Объектный файл содержит инструкции, но адреса в них не проставлены.
  - Компоновка (линковка) :: специальная программа *компоновщик* собирает исполняемый файл с инструкциями изо всех объектных файлов.

  В прошлых семинарах чтобы скомпилировать программу на ассемблере =hello.asm= мы
  выполняли следующие команды, не раскрывая их смысл:

  #+BEGIN_SRC sh
    nasm -f elf64 -o hello.o hello.asm
    ld -o hello hello.o
  #+END_SRC

  - В первой строчке запускается программа =nasm=, осуществляющая и /препроцессинг/ исходного кода и его /компиляцию/.

    #+BEGIN_SRC sh
      nasm -f elf64 -o hello.o hello.asm
    #+END_SRC

  - Во второй строчке запускается /компоновщик/, который делает из объектных файлов исполняемые.

    #+BEGIN_SRC sh
      ld -o hello hello.o
    #+END_SRC


  Если программа содержит несколько файлов, то каждый из них проходит
  препроцессинг и компиляцию отдельно от остальных. Затем все объектные файлы
  мы передаем компоновщику. Полная компиляция для трёх ассемблерных файлов =a.asm=, =b.asm= и
  =c.asm= с последующей компановкой в испольняемый файл =program= будет выглядеть так:

  #+BEGIN_SRC sh
    nasm -f elf64 -o a.o a.asm
    nasm -f elf64 -o b.o b.asm
    nasm -f elf64 -o c.o c.asm
    ld -o program a.o b.o c.o
  #+END_SRC

** Препроцессинг

   Препроцессинг производит в файле текстовые замены, описанные специальными командами. Это подготавливает программу к компиляции и позволяет полуавтоматически генерировать рутинный код, который иначе пришлось бы писать самостоятельно. Например, =%define= определяет замену одной строчки на другую:

   #+BEGIN_SRC asm
       ; После этой строчки символ `x` везде будет заменён на строчку "Hello"
       %define x "Hello"
     
     
       ; Пример использования:
       db x 
       db x 
       db x 
   #+END_SRC

   Фактически препроцессор из программы на языке "ассемблер + команды управления препроцессором" делает программу на языке ассемблера, готовую для компиляции.

   Чтобы остановить процесс сразу после препроцессора и посмотреть на изменённый код программы,  запустите =nasm= с ключом =-E=.

   *Вопрос* проведите следующий код через препроцессор и изучите результат.

   #+BEGIN_SRC asm
       ; После этой строчки символ `x` везде будет заменён на строчку "Hello"
       %define x "Hello"
     
     
       ; Пример использования:
       db x 
       db x 
       db x 
   #+END_SRC

Раскрытие команды =%define= происходит в момент ей использования, а не в момент создания. 
Поэтому можно изменить значение параметров, используемых внутри макроса, между вызовами.
Альтернативная команда =%xdefine% расрывается во время задания, поэтому не позволяет изменить переназначит значения переменных между вызовами.

   *Вопрос* проведите следующие два фрагмента код через препроцессор и сравните результат.

   #+BEGIN_SRC asm
       %define i 1
     
       %define d i * 3
     
       mov rax, d
     
       ; let's redefine i
       %define i 100
       mov rax, d
   #+END_SRC

   #+BEGIN_SRC asm
       %define i 1
     
       %xdefine d i * 3
     
       mov rax, d
     
       ; let's redefine i
       %define i 100
       mov rax, d
   #+END_SRC

*** Однострочные команды препроцессора с аргументами

Команды препроцессора могут использовать аргументы, имена которых записываются в круглых скобках после имени команды.

   *Вопрос* проведите следующий код через препроцессор и изучите результат. Что такое =x=? Скомпилируется ли эта программа?
 
   #+BEGIN_SRC asm
       %define process(x) (x * 3 + 23)
     
       mov rax,  process( 9 )
   #+END_SRC

Необходимо не забывать, что препроцессор работает исключительно с текстом. Поэтому код, который формируетя в результате работы препроцессора может быть некорректным с точки зрения компилятора, что будет запущен на следующем шаге.

   *Вопрос* проведите следующий код через препроцессор и изучите результат. Скомпилируется ли эта программа?

   #+BEGIN_SRC asm
       %define process(x) (x * 3 + 23)
     
       mov rax,  process( rcx )
   #+END_SRC
 
 *** Многострочные команды препроцессора

Кроме однострочных команд можно задавать и многострочные. Описываются они с использованием ключевого слова =%macro= и завершаются словом =%endmacro=. У данных команд может быть несколько аргументов, количество которых задается после имени макроса, и далее они используются по индексу, например =%1=, =%2= и так далее.

   *Вопрос* проведите следующий код через препроцессор и изучите результат. 
 
   #+BEGIN_SRC asm
       %macro test 3
       db %1
       db %2 
       db %3
       %endmacro
     
       test "hello", ",", " world"
   #+END_SRC

   *Задание 1* Напишите многострочный макрос, чтобы он выделял в памяти строку из своих аргументов, разделенную запятыми. Например при передаче аргументов =hello=, =another= и =world= в результате в памяти была выделена строка =hello, another, world=.

За более подробной о макросах можно обратиться к [[https://www.tortall.net/projects/yasm/manual/html/nasm-multi-line-macros.html][документации nasm]].
    
** Компилятор

   Задача компилятора --- перевести исходный код в набор исполняемых инструкций. В случае с языком ассемблера, этот процесс достаточно прозрачен: каждой мнемонике ассемблера соответствует инструкция процессора.
   При необходимости детали кодирования команд можно посмотреть на страничках инструкций в [[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html][Intel® 64 and IA-32 Architectures Software Developer’s Manual]].


   Для программ из нескольких файлов-модулей, компилируемых в изоляции друг от друга, возникает необходимость явно описывать, какие внешние функции/данные нам нужны в каждом файле. Пусть файл =a.asm= содержит функции =f= и =h=; при этом мы хотим использовать функцию =f= в файле =b.asm=. Тогда чтобы обеспечить взаимодействие между кодом из этих файлов:

   - То, что файл выставляет наружу другим модулям, мы отдельно декларируем как =global=.
   - То, что мы хотим импортировать из других файлов, в месте импорта декларируется как =extern=.

   #+BEGIN_SRC asm
       ; a.asm ; 
       global f
     
       ; h остаётся недоступной
     
       f: 
          код 
       h: 
          код 
   #+END_SRC

   #+BEGIN_SRC asm
       ; b.asm ;
       extern f
     
       ...
       call f ; работает
   #+END_SRC



* Описание интерфейсов

  Представим ситуацию, когда мы создали библиотеку =lib.asm=, в которой десять функций:

  #+BEGIN_SRC asm
      global f1
      global f2
      global f3
      ...
      global f10
  #+END_SRC

  Если мы хотим использовать эти функции в сотне других файлов, в каждом из них нужно будет прописать следующие строчки:

  #+BEGIN_SRC asm
      extern f1
      extern f2
      extern f3
      ...
      extern f10
  #+END_SRC

  В дальнейшем при разработке нам может захотеться расширить набор функций в =lib.asm= и добавить туда дополнительные функции. Тогда придётся вносить изменения в каждый из сотни файлов.

** Заголовочные файлы
  Более продуктивный подход к разработке заключается в том, чтобы для каждой библиотеки =lib.asm= выделить описание того, что нужно из неё импортировать в специальный файл =lib.inc=:

  #+BEGIN_SRC asm
    ; содержимое lib.inc
    extern f1
    extern f2
    extern f3
    ...
    extern f10
  #+END_SRC

  Тогда с помощью директивы препроцессора = %include "lib.inc" = можно включить =lib.inc= "как есть" во все файлы, нуждающиеся в библиотечных функциях. Фактически этот файл частично описывает внешний интерфейс взаимодействия с модулем =lib.asm= (полным описанием являются метки, помеченные =global= в самом файле =lib.asm=.

*Задание 2* На предыдущем семинаре вы работали с функцией =print_hex=. Создайте программу из трех файлов: первые два - это библиотека с функциями =print_hex= и =exit=, в третьем содержится метка =_start= и происходит вызов =print_hex=. Скомпилируйте их и запустите программу. (Создайте библиотеку =lib.asm= с двумя функциями: =print_hex= и =exit= для выхода из приложения. Напишите к ней заголовочный файл =lib.inc=. Протестируйте её, запустив функцию из другого файла с меткой =_start=.) В результате ваша программа должна состоять из трех файлов:
 - =lib.asm= - файл с реализацией функций =print_hex= и =exit=.
 - =lib.inc= - файл с заголовками функций =print_hex= и =exit=.
 - =main.asm= - файл с функцией =_start=, вызывающей функции =print_hex= и =exit=.

*Вопрос* Какие команды необходимы чтобы провести оба файла с кодом через весь цикл компиляции?

*Вопрос* для чего метка =_start= помечается как =global=?
    

   #+BEGIN_SRC asm
; print_hex.asm
section .data
codes:
    db      '0123456789ABCDEF'

section .text
global _start
    _start:
           mov  rdi, 0x1122334455667788
           call print_hex
           call exit
    
    print_hex:
           mov  rax, rdi
           mov  rdi, 1
           mov  rdx, 1
           mov  rcx, 64
         ; Each 4 bits should be output as one hexadecimal digit
         ; Use shift and bitwise AND to isolate them
         ; the result is the offset in 'codes' array
       .loop:
           push rax
           sub  rcx, 4
         ; cl is a register, smallest part of rcx
         ; rax -- eax -- ax -- ah + al
         ; rcx -- ecx -- cx -- ch + cl
           sar  rax, cl
           and  rax, 0xf
     
           lea  rsi, [codes + rax]
           mov  rax, 1
     
           ; syscall leaves rcx and r11 changed
           push rcx
           syscall
           pop  rcx
     
           pop  rax
         ; test can be used for the fastest 'is it a zero?' check
         ; see docs for 'test' command
           test rcx, rcx
           jnz  .loop
           ret

    exit:
           mov  rax, 60
           xor  rdi, rdi
           syscall
   #+END_SRC


** Компоновщик

   Компоновщик работает с полуфабрикатами --- объектными файлами --- и собирает из
   них исполняемый файл. Следующая команда переводит объектный файл =hello.o= в исполняемый файл =hello=.

   #+BEGIN_SRC sh
     ld -o hello hello.o
   #+END_SRC

   В этом курсе мы работаем с объектными файлами формата ELF. Помимо инструкций
   они содержат множество мета-информации про программу, необходимой для её
   загрузки, выполнения или отладки, например:

   - Какие строчки исходной программы на языке высокого уровня соответствуют каким ассемблерным инструкциям?
   - Какие функции начинаются с каких адресов?
   - Где находятся глобальные переменные?
   - Какие данные изменяемые, а какие должны быть защищены от перезаписи?
   - По какому адресу программа загружается в память?

*** Таблица символов
    
    Информация про ассемблерные метки после компиляции аккумулируется в /таблице символов/ и становится частью ELF-файла.

    Компоновщик использует таблицу символов чтобы связывать обращения по адресам и определения меток. Например, рассмотрим программу:

    #+BEGIN_SRC asm
        global _start
        section .data
        message: db  'hello, world!', 10
      
        section .text
        _start:
            mov  rsi, message 
    #+END_SRC

    С помощью утилиты =nm= мы можем посмотреть содержание её таблицы символов; мы увидим в ней только два символа:  =message= и =_start=:

    #+BEGIN_SRC sh
      > nm symbols.o
      00000000000000000 T _start
      0000000000000000 d message
    #+END_SRC

    *Вопрос* Объясните значение второго столбца.

    *Вопрос* Мы будем изучать исполняемые и объектные файлы с помощью утилит
    =readelf=, =nm= и =objdump=. Разберитесь, как посмотреть таблицу символов в =.o=-файле
    с помощью всех трёх (=man= содержат нужную информацию). Каждый раз обращайте внимание, как помечаются 
    локальные и глобальные символы.

    Инструкции в объектном файле можно посмотреть так:

    #+BEGIN_SRC sh
      > objdump -M intel-mnemonic -d symbols.o
      symbols.o:     file format elf64-x86-64
      
      Disassembly of section .text:
      
      0000000000000000 <.text>:
      0:   48 be 00 00 00 00 00    mov  rsi,0x0
      7:   00 00 00 
      
    #+END_SRC

    Что тут происходит:

    - В файле всего одна инструкция =mov rsi, <операнд>=, где операнд занимает 8 байт.
    - Операнд должен быть адресом =message=, но до компоновки адреса не проставлены: мы не знаем, начиная с какого адреса программа будет загружаться в память, и в каком порядке будут загружены объектные файлы, поэтому и точного значения адреса =message= не знаем.
    - Адрес начала секции =.text= неизвестен, поэтому он тоже установлен в 0.


    
    В таблицу символов попадает и другая служебная информация, например,
    адреса начала секций. Исполняемые файлы тоже имеют формат ELF, только в них
    больше информации. Например, в отличие от =.o=-файлов, в исполняемых файлах
    вписаны адреса, по которым каждая ассемблерная секция будет загружена в память.

    *Вопрос* могут ли несколько =.o=-файлов содержать метки с одинаковым именем?

*** Таблица релокаций
    
     Другая таблица, которая также присутствет в ELF-файлах, это таблица релокаций. Она показывает, где нужно "пропатчить" скомпилированный код чтобы вставить в инструкции адреса операндов на место заглушек-нулей.

     *Вопрос* Выполните следущие команды. Изучите поля =Offset=, =Sym.Value=, =Sym. Name + Addend= и поймите, чему они соответствуют в выводе дизассемблера от =objdump=.
     
    #+BEGIN_SRC sh
      > objdump -M intel-mnemonic -d symbols.o
      > readelf --relocs symbols.o
    #+END_SRC

  
    *Вопрос* изучите таблицы символов в файлах из задания с функцией =print_hex=. Как =global= и =extern= влияют на содержимое таблиц символов?
    


* Задание зависимостей процесса сборки

Теперь мы понимаем, что пока мы получим исполняемый файл из исходников, над кодом поработают многие другие программы: компилятор, препроцессор, компоновщик. 
В реальных проектах процесс сборки исполняемого файла из множества файлов с кодом, зачастую написанных на разных языках программирования, может быть очень сложен. Им даже занимаются специально выделенные специалисты.

При разработке программисты постоянно изменяют части программы и пересобирают программу чтобы провести тесты; при этом хочется, чтобы пересобирались только те файлы, которые изменились, и зависящие от них, иначе процесс пересборки может занимать часы.

В нашем курсе мы познакомимся с одним из распространённых инструментов для организации процесса сборки --- =make=. Это не особо хорошо спроектированный инструмент и не самый современный, но самый распространённый.


** Как оптимизировать процесс сборки?

Для примера рассмотрим проект, состоящий из трёх ассемблерных файлов: =a.asm=, =b.asm= и =c.asm=. Между файлами есть зависимости: прежде, чем собрать файл =c.o= нужно сначала собрать файлы =a.o= и =b.o=. На рисунке стрелки показывают зависимости: если $A \rightarrow B$, то $A$ необходим для сборки $B$.

#+attr_html: :width "300px"
[[./img/sample-project-schematic.svg]]

Объектные файлы, из которых собирается исполняемый файл, компилируются независимо. 
Значит в примере выше если мы изменили =a.asm= то не нужно перекомпилировать =b.asm= и =c.asm=. 
Достаточно шагов, которые в сумме выполнят эти команды:

#+BEGIN_SRC sh
nasm -f elf64 -o a.o a.asm
ld -o program a.o b.o c.o
#+END_SRC

Аналогично и если мы изменили =b.asm=, только команды для пересборки будут другими. Как бы заставить стороннюю программу просчитывать оптимальную последовательность команд для пересборки проекта какая бы его часть ни была изменена?


** makefile
Программа =make=  отслеживает взаимосвязи между файлами вида "если файл /A/ изменён, то нужно перекомпилировать не только его, но и еще файл /B/". Как только изменения в файл /A/ с кодом внесены и мы хотим пересобрать проект, =make= подсчитывает множество файлов, зависимых от /A/, и зависимых от зависимых от /A/ и так далее, транзитивно. 
Граф зависимостей мы предоставляем вручную в виде =makefile= (текстовый файл, который так и называется).

Зависимости задаются блоками текста вида:

#+BEGIN_SRC makefile
цель: зависимость1 зависимость2 ...
    команда1
    команда2
  ...
#+END_SRC
 
Где =цель= - цель или имя файла для сборки, =зависимости= - зависомости цели или файлы, от которых зависит текущая цель, а =команды= - команды, которые должны быть выполнены для сборки цели =цель=.

Вот пример простейшего =makefile= для этого проекта:

#+BEGIN_SRC makefile
# С решётки начинаются комментарии

# Файл это набор правил
# формат каждого правила: 
# имя_файла_для_сборки: зависимость1 зависимость2 ...
# <обязательно символ tab> команда1
# <обязательно символ tab> команда2
#                                              ...
#                                              
# имя файла для сборки также называется "цель", target

# a.o зависит от файла a.asm. Если изменился файл a.asm, нужно выполнить действие
a.o: a.asm
    nasm -f elf64 -o a.o a.asm

# b.o зависит от a.o но также и транзитивно от a.asm. 
# Не нужно указывать транзитивные зависимости, make их выводит сам

b.o: b.asm a.o
    nasm -f elf64 -o b.o b.asm

c.o: c.asm a.o
    nasm -f elf64 -o c.o c.asm

program: a.o b.o c.o
    ld -o program a.o b.o c.o
#+END_SRC

Сохраните этот текст в файле с именем =makefile= и запустите =make program= чтобы выполнить действия по сборке цели =program=.

*Задание 3* напишите =makefile= для программы из текущего семинара, состоящей из двух файлов; в одном хранились функции =exit= и =print_hex=, а  в другом содержались их вызовы.

*Вопрос* необходимо, чтобы вы освоились с терминами. В контексте =make=, что такое rule, target, prerequisites?

* Phony targets

Данный вид цели используется для целей, для которых не создается реальный выходной файл, например для цели удаления временных файлов. Например, можно задать цель =clean= следующим образом:

#+BEGIN_SRC makefile
clean:
    rm *.o temp
#+END_SRC
 
Дананя цель будет работать корректно до тех пор, пока название цели не будет совпадать с каким-либо именем файла. В случае, если в текущей директории имеется файл с именем =clean=, то команды цели никогда не будут выполняться: цель существует и у неё нет зависисмостей. Для исправления поведения цели необходимо явно указывать, что она не приводит к созданию файла с названием цели, используя ключевое слово =.PHONY=. Например:

#+BEGIN_SRC makefile
.PHONY: clean
clean:
    rm *.o temp
#+END_SRC

Более подробно про phony targets можно прочитать по ссылке [[https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html]].

** make как декларативный язык программирования
С точки зрения стилей программирования, =make= действует как декларативный язык программирования, такой, как Prolog. Мы описываем не последовательность действий для сборки, а набор ограчений (зависимости между файлами). Затем make на основании этого графа зависимостей и информации о том, какие именно файлы изменены, вычисляет последовательность, в которой нужно запустить действия, соответствующие минмальному набору правил для пересборки приложения.

Ещё менее =make= похож на традиционное императивное программирование когда его запускают в несколько потоков с помощью ключа =-j=. Последовательность команд внутри правила выполняется по порядку,  *но сами правила могут выполняться в любом порядке*.
Однако даже сборка идёт во много потоков, автоматически выполняется синхронизация  между ними, чтобы никакое правило не было запущено раньше, чем для него будут подготовлены все необходимые данные.

*Вопрос* прочитайте [[https://www.gnu.org/software/make/manual/make.html#How-Make-Works][секцию 2.3]] в документации на =make=. Что будет если не указать цель явно?  Какая цель по-умолчанию выполняется первой? Всегда ли это =all=?


** Переменные
   
В таких файлах можно создавать переменные. Часто имена и флаги компиляторов, линкеров и т.д. указывают в переменных. Чтобы подставить значение переменной =var= пишут =$(var)=. Это не переменные окружения, а переменные самого =make=!


#+BEGIN_SRC makefile
# тот же файл с переменными

ASM=nasm
ASMFLAGS=-f elf64
LD=ld

a.o: a.asm
    $(ASM) $(ASMFLAGS) -o a.o a.asm

# b.o зависит от a.o но также и транзитивно от a.asm. 
# Не нужно указывать транзитивные зависимости, make их понимает

b.o: b.asm a.o
    $(ASM) $(ASMFLAGS) -o b.o b.asm

c.o: c.asm a.o
    $(ASM) $(ASMFLAGS) -o c.o c.asm

program: a.o b.o c.o
    $(LD) -o program a.o b.o c.o
#+END_SRC

** Автоматические переменные

Для удобства написания =makefile= в нем можно используя автоматические переменные, фактические значения которых будут зависить от контекста.

Следующие автоматичесеие переменные помогут вам в написании ваших =makefile= файлов:

 - =$@= - цель (имя файла для сборки) текущего правила
 - =$<= - первая зависимость текущего правила
 - =$?= - список всех зависимостей текущего правила, которые новее, чем цель текущего правила, разделенных проблелами
 - =$^= - список всех зависимостей текущего правила, разделенных проблелами. Повторные включения зависимостей удаляются (каждая зависимость включается в список ровно один раз)
 - =$+= - список всех зависимостей текущего правила, разделенных проблелами. Повторные включения зависимостей *не* удаляются (зависимости перечисляются ровно в том порядке и количестве, как заданы в списке зависимостей)

Более подробно про автоматические переменные можно прочитать по ссылке [[https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html]].

** Шаблоны

Другим полезным инструметом при написании =makefile= являются шаблоны. Шаблон позволяет задать правило для группы файлов, которые собираются одинаковым образом, например для получения объектного файла из исходного файла с тем же именем. Общий вид шаблона следующий:

#+BEGIN_SRC makefile
%.o: %.c
    # правило для сборки произольного %.o файла из соответствующего %.c файла
#+END_SRC

Более подробно про использование шаблонов можно прочитать по ссылке [[https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html]].

*Задание 3.5* Перепишите =makefile= для =print_hex= написаного вами ранее так, чтобы использовать phony targets, переменные, автоматические переменные и шаблоны. Напишите pattern rule, которое подойдёт для создания объектного файла из любого ассемблерного файла и используйте его в свем =makefile= для =print_hex=.

*Задание 4* Напишите =makefile= для любой из ваших лабораторных по программированию с первого курса, для любой лабораторной по web-программированию, для первой или второй лабораторной по этому курсу,  или вообще для любой программы из более, чем двух файлов, которую вы когда-либо писали. Не зубудьте про использование phony target для сборки программы и удаления временных файлов.
