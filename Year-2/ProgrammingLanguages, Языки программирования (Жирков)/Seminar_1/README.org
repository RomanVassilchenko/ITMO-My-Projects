#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+LANGUAGE: ru
#+OPTIONS: ':t
#+OPTIONS: toc:1
#+OPTIONS: tasks:nil
#+TITLE: Семинар 1:  среда выполнения, основы языка ассемблера
 -----

 - На практических занятиях мы будем выполнять небольшую самостоятельную работу с помощью преподавателя практики.
 - Если вы успели выполнить все задания, то получаете 4 балла, в противном случае вы баллов не получаете.
 - Преподаватель практики может на своё усмотрение поощрять неполное решение.
 - Листочки содержат инструкции к выполнению заданий, немного теории и вопросы для проверки, находя ответы на которые вы продвигаетесь в изучении курса.

* Необходимые инструменты для курса
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  - Для выполнения всех заданий курса вам достаточно иметь Debian GNU\Linux 8.0+ или аналогичный дистрибутив с установленными:
    * NASM 2.11.05+
    * GCC 4.9.2+ или Clang 
    * GNU Make 4.0+
    * GDB 7.7.1+

  - Лабораторные работы по ассемблеру будет очень сложно выполнить на MacOS если вы ещё на нём не писали т.к. эта операционная система требует того, чтобы код был позиционно-независимый (PIC, не содержит абсолютных адресов), а то, как этого достичь, мы изучим лишь в конце курса.

  - Лабораторные работы на чистом C можно выполнять на MacOS.

  - Пользователи Windows могут установить виртуальную машину или использовать WSL или WSL2.
    - VirtualBox: [[https://www.virtualbox.org/wiki/Downloads]]
  - Мы предоставляем несколько образов виртуальных машин для VirtualBox:
    - Ubuntu 16 with standard desktop environment (VirtualBox): [[https://yadi.sk/d/CLf4D4IM3TSpsx]]
    - Debian 9 Minimal (.vmx) [[https://yadi.sk/d/BehMKGzS3LgXzG]]
    - Debian 9 + XFCE [[https://yadi.sk/d/01uFWHCw3SHzh9]]

        Логин/пароль =user=, пароль от пользователя =root= --- =qwerty=

    - Docker image (не тестировалась) [[https://github.com/kellyi/nasm-gcc-container]]

* Tема занятия
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

  Для выполнения заданий курса нам потребуется работать с командной строкой,
  использовать компилятор, линкер и отладчик. На этом занятии мы освежим уже
  известные нам навыки работы с ними, познакомимся с новыми сценариями
  использования и начнём разбирать ассемблерные программы.

  - Использование интерактивной оболочки
  - Переменные окружения
  - Регулярные выражения, =grep=
  - ~stdin~, ~stdout~, ~stderr~
  - Компиляция ассемблерных программ
  - Флаги компиляции
  - Разбор =Hello, world!=
  - Системные вызовы
  - Секции
  - Важные регистры общего назначения
  - Служебные регистры =rip=, =rsp=
  - Отладка. Настройка =gdb= для синтаксиса Intel. Файл =.gdbrc=
  - Изучение памяти в отладчике
  - Шаги вперёд и назад в отладчике


* Использование интерактивной оболочки 

  Любая операционная система предполагает наличие интерфейса взаимодействия между пользователем и различными компонентами компьютерной системы, т. е. наличие программного уровня, который поддерживает ввод команд и параметров для получения необходимых результатов. Такой программный уровень получил название /оболочка/ или, по-английски --- /shell/.

  Все оболочки имеют схожие функции и свойства:

  - Интерпретация команд.
  - Доступ к командам и результатам их выполнения.
  - Обработка файлов, операций стандартного ввода и вывода.
  - Реализация специального языка программирования оболочки.


** Вопросы (15 минут)
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
   - Какую оболочку используете вы?
   - Как поменять оболочку, которая используется по умолчанию?
   - Чем особенна оболочка =sh= и почему мы редко её используем напрямую?
   - Для каких целей сейчас в основном используется =sh=?
   - Как вывести результат выполнения команды в файл?
   - Что такое дерево процессов?

   - Что такое =stdin=, =stdout=, =stderr=?
   - Как соединить выход одной программы со входом другой?
   - Когда целесообразно использовать =stdout=, а когда --- =stderr=?

   По умолчанию стандартный ввод --- чтение с клавиатуры, стандартный вывод и стандартный вывод ошибок печатаются на экране.


* Регулярные выражения. grep

** grep

   С помощью доллара в начале строки мы обозначаем приглашение командной строки,
   то есть текст после доллара нужно ввести.
  
   Выполните следующие команды. Что вы наблюдаете?
#+BEGIN_SRC bash
$ echo "hello, world" > test
$ echo "hello, " >> test
$ echo "world" >> test

$ grep 'hello' test
#+END_SRC


   Как видите, =grep= ищет строчки в файлах, удовлетворяющие шаблону.
   Однако его возможности больше, чем просто искать фиксированные строчки --- в качестве шаблона для поиска можно задавать /регулярные выражения/.

   Можно воспринимать регулярные выражения как маленькие программы на очень специализированном языке. С тем же файлом =test= выполните:

   #+BEGIN_SRC bash
     $ grep 'hel*o' test
   #+END_SRC

   При задании шаблона можно использовать следующие специальные символы:

   - =*= Звёздочка в шаблоне означает "символ слева от звёздочки может повторяться ноль или более раз";
   - =\+= Экранированный плюс в шаблоне означает "символ слева от звёздочки может повторяться один или более раз";
   - =?= Вопрос в шаблоне означает "символ слева от звёздочки может повторяться ноль или один раз";
   - =\{= =\}= Экранированные фигурные скобки задают точное количество повторений символа слева;
   - =.= Точка означает любой символ;
   - =^= Символ =^= обозначает начало строки;
   - =$= Символ доллара обозначает конец строки;
   - =[= =]= Квадратные скобки используются для задания подмножества допустимых символов, например =[abc]=, =[a-cA-C]=. Символ =^= в данном случае используется для отрицания, например =[^a-c]= будет означать все символы кроме диапазона =[a-c]=;
   - =\<= =\>= Экранированные треугольные скобки задают начало и конец слова;
   - =\= Символ обратной косой черты испльзуется для экранирования других специальных символов, например =\\=, =\$=.
   

** Вопросы (15 минут)
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

   Используя [[https://www.opennet.ru/docs/RUS/bash_scripting_guide/c11895.html][статью]] ответьте на вопросы:

   - Как найти строчки строго из одного (любого) символа?
   - Как найти строчки с цифрами?
   - Как найти строчки где есть слово из трёх букв?
   - Как найти пустые строчки?
   - Какой ключ при запуске =grep= инвертирует результаты поиска, т.е. ищет строки, не удовлетворяющие шаблону? 


* Переменные окружения
  Переменные окружения --- именованные переменные, содержащие текстовую информацию, которую могут использовать запускаемые программы. Такие переменные могут содержать общие настройки системы, параметры графической или командной оболочки, данные о предпочтениях пользователя и многое другое.

  Некоторые переменные окружения хранят значения, которые используются для особых целей,  например:

  - директория, где по умолчанию ищутся динамические библиотеки :: =LD_LIBRARY_PATH=
  - место размещения исполняемых файлов в системе :: =PATH=
  - имя предпочитаемого текстового редактора :: =EDITOR=

** Вопросы (5 минут)
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

   - Наследуются ли переменные окружения в дочерних процессах? Если да, то все ли?
   - Зачем нужен =export= при запуске программ?
   - Как установить значение переменной окружения и запустить программу?


* Компиляция ассемблерных программ 

  Файл с кодом, который мы создаём --- текстовый, с расширением =.asm=. Его перевод в исполняемый машинный код происходит в два этапа:

  -  Компилятор ::  создаёт из него объектный файл с расширением =.o=; в нём содержатся машинные инструкции, но вместо их операндов-адресов там заглушки.
  -  *Линкер* (компоновщик) :: создаёт из одного или более объектных файлов исполняемый (в *nix системах без расширения).

    Мы научимся компилировать программы на ассемблере пока даже не знакомясь с самим языком.
    
  Скомпилируйте первый файл =hello.asm= и создайте исполняемый файл =hello=:

  #+BEGIN_SRC asm
      ; hello.asm 
        section .data
        message: db  'hello, world!', 10

        section .text
        global _start

        _start:
            mov     rax, 1           ; 'write' syscall number
            mov     rdi, 1           ; stdout descriptor
            mov     rsi, message     ; string address
            mov     rdx, 14          ; string length in bytes
            syscall

            mov     rax, 60          ; 'exit' syscall number
            xor     rdi, rdi
            syscall
  #+END_SRC

  Для этого выполните команды:

#+BEGIN_SRC bash 
$ nasm -g hello.asm -felf64 -o hello.o
$ ld -o hello hello.o
#+END_SRC

Для запуска:

#+BEGIN_SRC bash 
./hello
#+END_SRC
В ответ на запуск вы должны увидеть:


#+BEGIN_SRC bash 
Hello, world!
#+END_SRC


О флагах компиляции вы можете прочитать при помощи =man nasm=.

** Вопросы
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
   - Что значит параметр =-f elf64=?
   - Что значит параметр =-g=?
   - Что такое отладчик?

* Hello, world!
  
  Чуть ранее мы скомпилировали и запустили нашу первую программу на языке ассемблера.
  Рассмотрим её подробдней.

  #+BEGIN_SRC asm
      ; hello.asm 
        section .data
        message: db  'hello, world!', 10

        section .text
        global _start

        _start:
            mov     rax, 1           ; 'write' syscall number
            mov     rdi, 1           ; stdout descriptor
            mov     rsi, message     ; string address
            mov     rdx, 14          ; string length in bytes
            syscall

            mov     rax, 60          ; 'exit' syscall number
            xor     rdi, rdi
            syscall
  #+END_SRC


Чтобы программировать на ассемблере вам не нужно знать всё многообразие команд для AMD64. 
Для большинства сценариев достаточно знать ~30 инструкций, причём многие из них очень похожи.

Например:

- =jz= :: перейти на адрес если установлен флаг ZF (Zero flag)
- =js= :: перейти на адрес если установлен флаг SF (Sign flag)

... и так для каждого флага.
  
Прочитайте страницы 17--21 из книги "Low-level programming" чтобы понять, как выполняется программа.

*Задание* измените код программы Hello, world! так, чтобы она выводила два сообщения: одно в =stdout=, второе в =stderr=. Запустите программу перенаправив поток вывода =stdout= в файл =out.txt=, а =stderr= в файл =err.txt=.

** Вопросы (25 минут)
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

  - Что такое секция? Зачем они нужны?
  - Что такое метка (label)?
  - Что означает инструкция =xor r, r=, где =r= --- любой регистр?
  - Найдите страницу, соответствующую инструкции =mov= в Intel Sofware Developer Manual и просмотрите её.
    
      Пожалуйста, не используйте Google чтобы искать справки по командам --- используйте [[https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html][Intel® 64 and IA-32 Architectures Software Developer’s Manuals]] ([[https://gitlab.se.ifmo.ru/programming-languages/cse-programming-languages-fall-2022/main/-/blob/master/docs/intel-manual.pdf]])). Информация в интернете часто неактуальна и относится только к устаревшим моделям процессоров. 
       В части мануала под названием Instruction Reference есть странички для каждой инструкции.
 
  
* GDB (45 минут)

=gdb= это мощный отладчик, который можно использовать для изучения функционирования программы. Он позволяет выполнять программы по шагам и изучать её состояние, включая слепок памяти и регистров. Чтобы отлаживать программу зачастую мы исполяем её по шагам и следим за состоянием. Мы также можем исполнять её пока некоторое условие не станет истинным или до определённого места в коде. Такое место называется /breakpoint/, или /точка останова/.

У =gdb= есть собственная система команд, управляющая программой, которую вы изучаете. Поэтому когда вы запускаете =gdb= вы видите его приглашение командной строки, куда вы и вводите команды. Отличие работы с =gdb= через его систему команд, а не графический интерфейс с кнопками, в том, что текстовые команды можно комбинировать в скрипты, автоматизирующие работу с отлаживаемой программой.

** Запуск программы в =gdb=

Есть два основных способа использовать =gdb= с программой: с помощью его
собственной команды =file=, или запустив с путём к программе в качестве
аргумента.

#+BEGIN_SRC
(gdb) file hello
Reading symbols from hello ...(no debugging symbols found)...done.
#+END_SRC

** Основные команды

*С помощью клавиши =<tab>= вы можете вызывать автодополнение.*

Две самые важные команды:

- =quit= выход
- =help cmd= справка по команде =cmd=

** Файл =.gdbinit=

Команды из файла =~/.gdbinit= выполняются при старте =gdb=. 
Добавьте туда строчку:

#+BEGIN_SRC
set auto-load safe-path /
#+END_SRC

Тогда вы сможете создавать файл =.gdbinit= и в директории с файлом, который вы
отлаживаете.


** Переключение на Intel синтаксис

По умолчанию =gdb= для ассемблера использует AT&T синтаксис. Чтобы перманентно переключиться на Intel-синтаксис добавьте в =.gdbinit=:

#+BEGIN_SRC
set disassembly-flavor intel
#+END_SRC

** Команды управления программой

Ещё некоторые полезные команды =gdb= (текст в =<угловых скобках>= заменяется на аргументы):

- =run= запускает выполнение программы;
- =break <метка>= ставит точку останова на метку. Во время работы программы с подключенным отладчиком она будет останавливаться как только доходит до такой точки;
- =break *<адрес>= ставит точку останова на определённый адрес;
- =continue= продолжает выполнение программы;
- =stepi= (сокращённо =si=) выполняет ровно одну инструкцию;
- =nexti= (сокращённо =ni=) выполняет ровно одну инструкцию, но не заходит в функции, вызванные с помощью инструкции ассемблера =call=. Будет выполнена вся функция и программа остановится на следующей в коде после =call= инструкции.
- =layout= переключается между режимами интерфейса, см. далее.

** Запуск и исследование программы

 Загрузим Hello, world! в отладчик, установим брейкпоинт на метку =_start=, с которой начинается выполнение любой ассемблерной программы, и запустим её.

 [[./img/gdb-1.png]]

 Чтобы нам было удобнее наблюдать состояние программы, мы включим режим псевдографики.


 #+BEGIN_SRC
 layout asm
 layout regs
 #+END_SRC

 В этом режиме есть три окна:

 - Вверху видны названия регистров и их текущие значения;
 - В средней части виден результат дизассемблирования программы;
 - Внизу вы по прежнему можете вводить команды.


 [[./img/gdb-2.png]]

 В фокусе находится только одно из этих окон; с помощью =Ctrl-X= и =o= вы
 можете менять фокус и затем взаимодействовать с другими окнами.
 Стрелками можно скроллить окно, на котором установлен фокус.
 С помощью =Ctrl+L= можно перерисовать интерфейс.


*Задание* с помощью =gdb= запустите программу Hello, world!. Выполните её по шагам. В чём разница между =nexti=, =stepi=? Что такое step over?

*** Состояние программы

В следующих двух командах используется обозначение =/FMT= для указания формата данных.

- =print /FMT <val>= позволяет посмотреть содержимое регистров или памяти. Регистры предваряются долларом, например, =print /x $rax=.
- =x /FMT <address>= позволяет смотреть содержимое памяти. Он отличается от =print= тем, что принимает адрес, т.е. имеет один уровень косвенности.

     =/FMT= позволяет нам явно указывать тип данных, который мы изучаем. В зависимости от него меняются две вещи:
     
     - формат отображения (например, основание системы счисления);
     - ожидаемый размер. 

      Например, в памяти лежит двоичное число =0xff78=. Если мы считаем 1 байт равный =0x78=, то это число мы интерпретируем как положительное; если же мы считаем 2 байта, то оно может быть интерпретировано как отрицательное (почему?)


      Самые полезные форматы:
      
      * =x= (hexadecimal) 
      * =a= (address)
      * =i= (instruction, =gdb= попытается дизассемблировать инструкцию начиная с данного адреса)
      * =c= (char)
      * =s= (null-terminated string) -- строка, в которой каждый байт соответствует
        коду символа по таблице ASCII, а конец строки обозначен символом с кодом
        =0x00=.
      
      Самые полезные размеры: =b= (байт) =g= (giant, 8 байт).


*Задание* с помощью =gdb= запустите программу Hello, world! Проследите за изменениями регистров =rip= на протяжении работы программы. Что оно означает? Также обратите внимание на значение =rax= после системного вызова =write=.

** Примеры команд


 * Посмотреть содержимое =rax=:

#+BEGIN_SRC
(gdb) print $rax
$1 = 1234605616436508552
#+END_SRC

 * Посмотреть первый символ строчки которая находится на метке =message=:

#+BEGIN_SRC
(gdb) print /c (char)message
$2 = 'h'
#+END_SRC


 * Дизассемблирование инструкции по адресу =_start= (тут используется оператор =&= для взятия адреса метки):

#+BEGIN_SRC
(gdb) x /i &_start
   0x4000b0 <_start>:   movabs rax,0x1122334455667788
#+END_SRC

 * Дизассемблирование следующей инструкции:

#+BEGIN_SRC
(gdb) x /i $rip
=> 0x4000e9 <_start.loop+32>:   jne    0x4000c9 <_start.loop>
#+END_SRC

 * Чему равны 5 первых символов начиная с метки =message=?

#+BEGIN_SRC
(gdb) x /5cb &message
0x402000 <message>:     104 'h' 101 'e' 108 'l' 108 'l' 111 'o'
#+END_SRC

Формат может начинаться с указания количества элементов. Поэтому =/12cb= означает "12 элементов-символов, каждый по 1 байту".


  * Посмотреть последние 8 байт в стеке:

#+BEGIN_SRC
(gdb) x /xg $rsp
0x7fffffffdf90: 0x0000000000000001
#+END_SRC


 * Посмотреть второй элемент размера =qword= (8 байт) в стеке:
    
#+BEGIN_SRC
(gdb) x /xg $rsp
(gdb) x/xg $rsp+8
0x7fffffffd168:	0x00007fffffffd513
#+END_SRC

*Вопрос* прочитайте =help x=.

Чтобы использовать =gdb= эффективно, не забывайте про ключ компиляции =-g= (зачем?).

Кроме того, =gdb= позволяет перемещаться и изучать стек вызовов, вычислять арифметические выражения, запускать функции, автоматизировать отладку с помощью скриптов на Python и многое другое. 


** Запись и шаги назад

При прямом выполнении программы состояние системы изменяется после выполнения каждой инсткурции, соответственно теряется возможность сделать шаг назад при отладке, то есть восстановить предыдушее состояние. Для получения возможности обратного выполнения программ необходимо записывать изменение сотояния системы после каждой комманды. Некоторые системы поддерживают автоматическую запись, для других же требуется запускать её вручную. Отладчике =gdb= позволяет осуществить это с помощью следующих команд:

 - =record= запускает запись
 - =record stop= завершает запись

Более подробную документацию по записи выполнения программы и командах можно прочитать [[https://sourceware.org/gdb/onlinedocs/gdb/Process-Record-and-Replay.html][в документации]].

Пока выполняется запись становится возможно делать шаги назад:

 - =reverse-stepi= делает шаг назад ровно на одну инструкцию. Обращает выполнение команды =stepi= или =si=; 
 - =reverse-nexti= делает шаг назад ровно на одну инструкцию, но не заходит в функции. Обращает выполнение команды =nexti= или =ni=.

На [[https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html][этой странице]] представлена подробная документация по командам для выполнения программы назад.

*Задание*  Попробуйте при отладке программы пройти назад, а не вперед.

Если вам интересно узнать больше о возможностях GDB, советуем взглянуть на ресурс [[http://sourceware.org/gdb/current/onlinedocs/gdb/][Debugging with gdb]].

*Задание*  Пройдите по шагам следующую программу и проследите за изменением значения регистра =rax=:

  #+BEGIN_SRC asm
        section .text
        global _start

        _start:
            mov     rax, 0FFFFFFFFFFFFFFFFh
            mov     al, 0
            mov     ax, 0
            mov     eax, 0

            mov     rax, 60
            xor     rdi, rdi
            syscall
  #+END_SRC


